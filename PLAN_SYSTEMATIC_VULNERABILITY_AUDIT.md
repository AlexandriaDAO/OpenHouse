# AUTONOMOUS PR ORCHESTRATOR - DO NOT SKIP

**You are an autonomous PR orchestrator. Your ONLY job is to implement this plan and create a PR.**

## Isolation Check (RUN FIRST)
```bash
REPO_ROOT=$(git rev-parse --show-toplevel)
if [ "$REPO_ROOT" = "/home/theseus/alexandria/openhouse" ]; then
    echo "FATAL: In main repo. Must be in worktree."
    echo "Worktree: /home/theseus/alexandria/openhouse-security-audit"
    exit 1
fi
echo "In isolated worktree: $REPO_ROOT"
```

## Your Autonomous Workflow (NO QUESTIONS ALLOWED)
1. **Verify isolation** - You must be in worktree: `/home/theseus/alexandria/openhouse-security-audit`
2. **Execute the audit** - Follow each scan methodology below
3. **Document findings** - Create `SECURITY_AUDIT_RESULTS.md` with all findings
4. **Create PR** (MANDATORY):
   ```bash
   git add .
   git commit -m "security: Systematic vulnerability audit with mechanical discovery methodology"
   git push -u origin feature/systematic-vulnerability-audit
   gh pr create --title "security: Systematic Vulnerability Audit" --body "$(cat <<'EOF'
## Summary
Systematic security audit using mechanical vulnerability discovery methodology.

## Methodology
- TOCTOU scan: All await points analyzed for stale state usage
- Rollback consistency: All multi-await functions checked
- Arithmetic safety: All balance operations verified
- Access control: All update functions checked for caller verification
- IC-specific: Candid parsing, cycle attacks, upgrade safety

## Audit Scope
- 36 async functions
- 42 await points
- 129 state mutations
- 40 arithmetic balance operations

## Deliverables
- `SECURITY_AUDIT_RESULTS.md` - Complete findings
- `scripts/security-scan.sh` - Reusable audit tooling

Generated with Claude Code
EOF
)"
   ```

5. **Iterate autonomously** on review feedback

## CRITICAL RULES
- NO questions ("should I?", "want me to?")
- NO skipping PR creation - it's MANDATORY
- Document ALL findings, even if they look safe
- Create reusable tooling for future audits

**Branch:** `feature/systematic-vulnerability-audit`
**Worktree:** `/home/theseus/alexandria/openhouse-security-audit`

---

# Systematic Vulnerability Discovery Plan

## Philosophy

**The goal is NOT to find bugs you already know about.**
**The goal is to mechanically scan for patterns that COULD be bugs.**

Traditional testing: "Does this specific thing work?"
Security scanning: "What patterns exist that could be exploited?"

---

## Scan 1: TOCTOU (Time-of-Check-Time-of-Use)

### The Pattern
```
READ state → AWAIT → USE stale state
```

### Mechanical Process

```bash
# Step 1: Find all await points with context
grep -B20 "\.await" */src/**/*.rs | grep -v test > /tmp/await_contexts.txt

# Step 2: For each await, extract variables assigned before it
# Look for: let X = something.get() ... .await ... use X
```

### Checklist for Each Async Function

For every `pub async fn` in the codebase:

| Function | File:Line | State Read Before Await? | Used After Await? | Verdict |
|----------|-----------|-------------------------|-------------------|---------|
| [name] | [location] | [yes/no + what] | [yes/no + how] | [SAFE/VULN/REVIEW] |

### What to Document

For each function, trace:
1. What variables are assigned before the first `.await`?
2. Do any of those variables come from shared state (balances, pools, shares)?
3. Are those variables used after the `.await` returns?
4. Could another message modify that shared state during the await?

### Known Safe Patterns
- State read AFTER await (e.g., `deposit()` reads balance after transfer)
- State written BEFORE await with rollback (e.g., CEI pattern)
- Atomic operations with no await between read/write

### Known Vulnerable Patterns
- `let balance = get_balance()` ... `await` ... `new = balance - amount`
- `let shares = get_shares()` ... `await` ... `mint(shares * ratio)`

---

## Scan 2: Rollback Consistency

### The Pattern
```
STATE_CHANGE_1 → AWAIT → STATE_CHANGE_2 (what if await fails?)
```

### Mechanical Process

```bash
# Find functions with multiple state changes AND awaits
grep -l "\.borrow_mut\|\.insert\|\.remove" */src/**/*.rs | \
  xargs -I{} sh -c 'grep -l "\.await" {} && echo {}'
```

### Checklist

For every function with state changes + awaits:

| Function | State Changes | Await Points | Rollback on Failure? | Verdict |
|----------|--------------|--------------|---------------------|---------|
| [name] | [list them] | [count] | [yes/no/partial] | [SAFE/VULN] |

### What to Document

1. List all state mutations in the function (in order)
2. List all await points (in order)
3. For each await that can fail:
   - What state was already changed?
   - Is there rollback logic?
   - Is the rollback complete or partial?

### Known Safe Patterns
- All state changes after final await (no rollback needed)
- Explicit rollback in error handling for each prior change
- Using pending/scheduled state that doesn't commit until success

### Known Vulnerable Patterns
- `state1.insert(x)` → `await` fails → state1 not rolled back
- Partial rollback (rollback A but forget B)
- Rollback uses stale values

---

## Scan 3: Arithmetic Safety

### The Pattern
```
Any math on balances/amounts that could overflow/underflow
```

### Mechanical Process

```bash
# Find all arithmetic on u64 values
grep -rn "\+ \|\\- \|\\* \|/ " */src/**/*.rs | grep "u64\|amount\|balance\|payout"

# Find unchecked arithmetic (NOT using checked_*/saturating_*)
grep -rn "= .*[+\-\*/]" */src/**/*.rs | grep -v "checked_\|saturating_"
```

### Checklist

| Location | Operation | Type | Protected? | Overflow Possible? | Verdict |
|----------|-----------|------|------------|-------------------|---------|
| [file:line] | [a + b] | [u64] | [checked_add/no] | [yes/no] | [SAFE/VULN] |

### What to Document

1. Every arithmetic operation on financial values
2. Whether it uses checked/saturating variants
3. What happens on overflow (panic? wrap? error?)
4. Whether the values could realistically overflow

### Known Safe Patterns
- `checked_add().ok_or("overflow")?`
- `saturating_sub()` where 0 is acceptable minimum
- Nat (arbitrary precision) for share calculations

### Known Vulnerable Patterns
- `a + b` without checked (can panic or wrap)
- `a * b` on large values (easy overflow)
- `a / b` without zero check

---

## Scan 4: Access Control

### The Pattern
```
Update function callable by anyone when it should be restricted
```

### Mechanical Process

```bash
# Find all #[update] functions
grep -B2 -A10 "#\[update\]" */src/**/*.rs

# Check which ones verify caller
grep -B2 -A10 "#\[update\]" */src/**/*.rs | grep -A10 "pub async fn\|pub fn" | grep "caller\|require_admin\|msg_caller"
```

### Checklist

| Function | Restriction Needed? | Restriction Present? | Verdict |
|----------|--------------------|--------------------|---------|
| [name] | [admin/user/any] | [yes/no] | [SAFE/VULN] |

### What to Document

For each `#[update]` function:
1. Who should be able to call it? (anyone, only deposited users, only admin)
2. Is there a caller check?
3. What damage could an unauthorized caller do?

### Known Safe Patterns
- `require_admin()?` at function start
- Caller-specific operations (withdraw your own balance)
- Stateless queries exposed as update (harmless)

### Known Vulnerable Patterns
- Admin functions without admin check
- Functions that modify other users' state
- Initialization functions callable after init

---

## Scan 5: IC-Specific Vulnerabilities

### 5a: Candid Decoding

```bash
# Find all public endpoints and their argument types
grep -A5 "#\[update\]\|#\[query\]" */src/**/*.rs | grep "fn.*("
```

Check for:
- Vec<T> arguments (DoS via large vectors)
- String arguments (DoS via large strings)
- Nested structures (stack overflow)

### 5b: Cycle Drain

```bash
# Find expensive operations in query functions
grep -A20 "#\[query\]" */src/**/*.rs | grep "iter\|loop\|for\|while"
```

Check for:
- Unbounded iteration in queries (free to call, expensive to execute)
- Large data structure traversal

### 5c: Upgrade Safety

```bash
# Check pre/post upgrade hooks
grep -A20 "pre_upgrade\|post_upgrade" */src/**/*.rs
```

Check for:
- All stable state properly serialized
- State migration handles version differences
- No panics possible in upgrade hooks

### 5d: Inter-Canister Call Failures

```bash
# Find all inter-canister calls
grep -rn "ic_cdk::api::call::call\|ic_cdk::call" */src/**/*.rs
```

Check for:
- What happens if the call fails?
- Is state consistent after failure?
- Are there retry mechanisms where needed?

---

## Scan 6: Concurrency Matrix

Create a matrix of all operations that could run concurrently:

| Op A | Op B | Conflict? | Protected? | Notes |
|------|------|-----------|------------|-------|
| deposit | deposit (same user) | ? | ? | |
| deposit | withdraw (same user) | ? | ? | |
| deposit | play_game (same user) | ? | ? | |
| withdraw | withdraw (same user) | ? | ? | |
| LP deposit | LP withdraw (same user) | ? | ? | |
| LP deposit | user withdraw (diff user) | ? | ? | |
| play_game | play_game (same user) | ? | ? | |

For each pair:
1. Can they actually run concurrently? (await points allow interleaving)
2. Do they share state?
3. Is there a guard/lock?
4. What's the worst case outcome?

---

## Deliverables

### 1. `SECURITY_AUDIT_RESULTS.md`

Structure:
```markdown
# Security Audit Results

## Executive Summary
- Total functions audited: X
- Critical findings: X
- High findings: X
- Medium findings: X
- Low/Info: X

## Scan 1: TOCTOU Results
[Table of all async functions with verdicts]

## Scan 2: Rollback Consistency Results
[Table of all multi-state functions with verdicts]

## Scan 3: Arithmetic Safety Results
[Table of all arithmetic operations with verdicts]

## Scan 4: Access Control Results
[Table of all update functions with verdicts]

## Scan 5: IC-Specific Results
[Findings from each sub-scan]

## Scan 6: Concurrency Matrix
[Full matrix with analysis]

## Detailed Findings
### Finding 1: [Title]
- **Severity**: Critical/High/Medium/Low/Info
- **Location**: file:line
- **Description**: What's wrong
- **Exploit Scenario**: How to exploit
- **Recommendation**: How to fix
- **Status**: New/Known/Fixed
```

### 2. `scripts/security-scan.sh`

Reusable script that runs all the grep patterns and generates a preliminary report:

```bash
#!/bin/bash
# PSEUDOCODE

echo "=== TOCTOU Scan ==="
# Find await contexts, flag potential issues

echo "=== Rollback Scan ==="
# Find state+await combinations

echo "=== Arithmetic Scan ==="
# Find unprotected arithmetic

echo "=== Access Control Scan ==="
# Find unprotected updates

echo "=== IC-Specific Scan ==="
# Run IC-specific checks
```

---

## Success Criteria

This audit is successful if:

1. **Complete Coverage**: Every async function has a TOCTOU verdict
2. **Mechanical Process**: The methodology could be repeated by anyone
3. **Reusable Tooling**: `security-scan.sh` can be run on future code
4. **Clear Documentation**: Each finding has location, description, exploit scenario
5. **No False Confidence**: Document uncertainties and areas needing manual review

---

## Timeline

This is a research/audit task. Execute each scan methodically:

1. Scan 1 (TOCTOU): Analyze all 36 async functions
2. Scan 2 (Rollback): Analyze functions with state+await
3. Scan 3 (Arithmetic): Check all 40 balance operations
4. Scan 4 (Access Control): Check all update functions
5. Scan 5 (IC-Specific): Run specialized checks
6. Scan 6 (Concurrency): Build and analyze matrix
7. Compile results and create PR

---

## Notes

This methodology is designed to find bugs BEFORE you know they exist. The key insight:

**Don't ask "is this specific code secure?"**
**Ask "what patterns exist that could be insecure?"**

The grep patterns and checklists turn security auditing from "creative guessing" into "mechanical scanning."
