# Dice Backend Accounting System - Plain English Pseudocode
# This file explains the accounting.rs module in human-readable terms

overview:
  purpose: "Manage user deposits, withdrawals, and house balance for the dice game"
  key_principle: "On-demand calculation instead of caching for accuracy and simplicity"

constants:
  ICP_TRANSFER_FEE: "10,000 e8s (0.0001 ICP) - network fee for transfers"
  MIN_DEPOSIT: "10,000,000 e8s (0.1 ICP) - minimum deposit amount"
  MIN_WITHDRAW: "10,000,000 e8s (0.1 ICP) - minimum withdrawal amount"
  USER_BALANCES_MEMORY_ID: "10 - stable memory location for user balances"
  ICP_LEDGER_CANISTER_ID: "ryjl3-tyaaa-aaaaa-aaaba-cai - ICP ledger canister"

data_structures:
  USER_BALANCES_STABLE:
    type: "Stable BTree Map (persists across upgrades)"
    stores: "Principal → u64 mapping"
    description: "Each user's internal balance in e8s"
    persistence: "Survives canister upgrades automatically"

  AccountingStats:
    total_user_deposits: "Sum of all user balances"
    house_balance: "Canister ICP minus user deposits"
    canister_balance: "Total ICP in the canister"
    unique_depositors: "Number of users with balances"

helper_functions:
  calculate_total_deposits:
    purpose: "Sum all user balances to get total deposits"
    input: "none"
    process:
      - "Loop through USER_BALANCES_STABLE"
      - "Add up all balance values"
    output: "Total deposits as u64"
    note: "Called on-demand, no caching needed"

  get_canister_balance_from_ledger:
    purpose: "Query the actual ICP balance from the ledger"
    input: "none"
    process:
      - "Create account struct with our canister ID"
      - "Call ICP ledger's icrc1_balance_of method"
      - "Convert Nat response to u64"
    output: "Result<u64, String>"
    note: "Always returns fresh data directly from ledger"

  rollback_balance_change:
    purpose: "Undo a balance change if transfer fails (DRY helper)"
    input: "user Principal, original_balance u64"
    process:
      - "Restore user's balance to original amount"
    output: "none"
    note: "Used in withdraw error handling"

main_functions:
  deposit:
    purpose: "User deposits ICP into their game balance"
    input: "amount (u64 in e8s)"

    validation:
      - "Check: amount >= MIN_DEPOSIT (0.1 ICP)"
      - "If not: return error"

    process:
      step_1_transfer:
        description: "Transfer ICP from user to canister"
        action:
          - "Create transfer args (to: canister, amount: user's amount)"
          - "Call ICP ledger icrc1_transfer"
          - "User pays: amount + fee, canister receives: amount"

      step_2_credit:
        description: "Update user's internal balance"
        action:
          - "Get current balance from USER_BALANCES_STABLE"
          - "Add deposit amount to current balance"
          - "Store new balance in USER_BALANCES_STABLE"

      step_3_done:
        description: "Log success and return new balance"
        note: "No cache to update - totals calculated on-demand"

    output: "Result<new_balance, error_message>"

  withdraw:
    purpose: "User withdraws ICP from their game balance"
    input: "amount (u64 in e8s)"

    validation:
      - "Check: amount >= MIN_WITHDRAW (0.1 ICP)"
      - "Check: user balance >= amount"
      - "If either fails: return error"

    process:
      step_1_deduct:
        description: "Deduct balance FIRST (prevents re-entrancy)"
        action:
          - "Get user's current balance"
          - "Calculate: new_balance = current - amount"
          - "Update USER_BALANCES_STABLE with new balance"
        note: "Done before transfer to prevent concurrent withdrawals"

      step_2_transfer:
        description: "Transfer ICP from canister to user"
        action:
          - "Create transfer args (to: user, amount: amount - fee)"
          - "Call ICP ledger icrc1_transfer"
          - "User receives: amount - fee"

      step_3_handle_result:
        on_success:
          - "Log withdrawal"
          - "Return new balance"
        on_failure:
          - "Call rollback_balance_change(user, original_balance)"
          - "Return error"

    output: "Result<new_balance, error_message>"

  withdraw_all:
    purpose: "Convenience function to withdraw entire balance"
    process:
      - "Get user's current balance"
      - "Check balance > 0 and >= MIN_WITHDRAW"
      - "Call withdraw(balance)"
    output: "Result<new_balance, error_message>"

query_functions:
  get_balance:
    purpose: "Check any user's balance"
    input: "user Principal"
    process:
      - "Look up user in USER_BALANCES_STABLE"
      - "Return balance or 0 if not found"
    output: "u64"
    type: "query (fast, read-only)"

  get_my_balance:
    purpose: "Check caller's own balance"
    process:
      - "Get caller's Principal"
      - "Call get_balance(caller)"
    output: "u64"
    type: "query (fast, read-only)"

accounting_functions:
  get_house_balance:
    purpose: "Calculate current house profit/loss"

    formula: "canister_balance - total_user_deposits"

    process:
      step_1: "Query ledger for actual canister balance"
      step_2: "Calculate total deposits (sum all user balances)"
      step_3: "Subtract: house = canister - deposits"
      step_4: "Return house balance (or 0 if negative)"

    output: "Result<u64, String>"
    type: "update (calls ledger, ~500ms)"

    interpretation:
      positive: "House is winning"
      zero: "Break even"
      negative: "Impossible unless exploited"

  get_accounting_stats:
    purpose: "Get complete accounting snapshot"

    process:
      - "Calculate total deposits (sum all balances)"
      - "Count unique depositors"
      - "Query ledger for canister balance"
      - "Calculate house balance"
      - "Return all stats in struct"

    output: "Result<AccountingStats, String>"
    type: "update (calls ledger, ~500ms)"
    use_case: "Dashboards, monitoring, analytics"

  audit_balances:
    purpose: "Verify accounting integrity"

    audit_equation: "house_balance + total_deposits = canister_balance"

    process:
      step_1: "Calculate total deposits"
      step_2: "Query ledger for canister balance"
      step_3: "Calculate house balance"
      step_4: "Check: (house + deposits) == canister"
      step_5_pass: "Return success message with numbers"
      step_5_fail: "Return error message with discrepancy"

    output: "Result<String, String>"
    type: "update (calls ledger, ~500ms)"
    use_case: "Security audits, integrity checks"

internal_functions:
  update_balance:
    purpose: "Update user balance after game (win/loss)"
    caller: "game.rs after dice roll completes"
    input: "user Principal, new_balance u64"

    process:
      - "Update USER_BALANCES_STABLE with new balance"
      - "Done - totals calculated on-demand"

    output: "Result<(), String>"

    note: |
      This was the CRITICAL BUG FIX:
      Previously tried to update cached TOTAL_USER_DEPOSITS
      but calculation was wrong, causing drift.
      Now we just update the balance and calculate totals
      fresh each time they're needed.

upgrade_hooks:
  pre_upgrade_accounting:
    purpose: "Prepare for canister upgrade"
    process:
      - "Nothing needed"
      - "StableBTreeMap handles persistence automatically"

  post_upgrade_accounting:
    purpose: "Restore state after upgrade"
    process:
      - "Nothing needed"
      - "We calculate totals on-demand, no cache to restore"

compatibility:
  refresh_canister_balance:
    purpose: "Backwards compatibility with game.rs"
    process:
      - "Query ledger for balance"
      - "Return balance or 0 if error"
      - "Log any errors for monitoring"
    output: "u64"
    type: "update (calls ledger)"
    note: "game.rs may call this, so we keep the function"

key_design_decisions:
  on_demand_calculation:
    why: "Eliminates cache synchronization bugs"
    trade_off: "Slight latency increase vs guaranteed accuracy"
    impact: "Accounting functions now ~500ms instead of ~2ms"
    acceptable_because: "These are admin/monitoring functions, not hot path"

  no_cached_totals:
    why: "update_balance() couldn't reliably update caches"
    solution: "Calculate from source of truth (USER_BALANCES_STABLE)"
    benefit: "Impossible for totals to drift from reality"

  stable_storage:
    why: "User balances must survive upgrades"
    implementation: "StableBTreeMap in stable memory"
    benefit: "Automatic persistence, no manual serialization"

  error_handling:
    ledger_calls: "Use .expect() with clear messages (will halt on invalid principal)"
    balance_queries: "Return 0 for missing users (safe default)"
    transfer_failures: "Rollback balance changes (maintain invariants)"

security_considerations:
  re_entrancy:
    protection: "Deduct balance BEFORE transfer in withdraw"
    prevents: "User can't withdraw same funds twice"

  validation:
    deposits: "Check minimum amount before processing"
    withdrawals: "Check balance sufficiency before deducting"

  audit:
    equation: "house + deposits = canister"
    frequency: "Can be called anytime to verify integrity"

  immutability:
    balances: "Only modified through controlled functions"
    ledger: "Source of truth for actual ICP holdings"

example_flows:
  user_deposits_1_ICP:
    step_1: "User calls deposit(100_000_000)"
    step_2: "Validate amount >= MIN_DEPOSIT ✓"
    step_3: "Transfer 1 ICP from user to canister via ledger"
    step_4: "User balance: 0 → 100_000_000"
    step_5: "Return new balance: 100_000_000"

  user_plays_and_wins:
    step_1: "User bets 0.5 ICP on dice roll"
    step_2: "game.rs deducts bet: balance 100M → 50M"
    step_3: "User wins! Payout: 1 ICP (2x multiplier)"
    step_4: "game.rs calls update_balance(user, 150M)"
    step_5: "User balance now: 150M (0.5 bet + 1.0 win)"

  user_plays_and_loses:
    step_1: "User bets 0.5 ICP on dice roll"
    step_2: "game.rs deducts bet: balance 100M → 50M"
    step_3: "User loses"
    step_4: "Balance stays: 50M"
    step_5: "House gains: 0.5 ICP"

  checking_accounting:
    step_1: "Admin calls get_accounting_stats()"
    step_2: "Calculate total_deposits: sum(all balances) = 200M"
    step_3: "Query ledger: canister_balance = 250M"
    step_4: "Calculate house: 250M - 200M = 50M"
    step_5: "Return stats: deposits=200M, house=50M, canister=250M"

  audit_check:
    step_1: "Call audit_balances()"
    step_2: "total_deposits = 200M, canister = 250M, house = 50M"
    step_3: "Check: 50M + 200M == 250M ✓"
    step_4: "Return: '✅ Audit passed: house (50M) + deposits (200M) = canister (250M)'"

common_questions:
  why_not_cache_totals:
    question: "Why not cache total_deposits for performance?"
    answer: |
      We tried that! The bug was that update_balance() didn't
      update the cache correctly. Every time a game was played,
      the total would drift from reality. By calculating on-demand,
      we guarantee accuracy at the cost of ~500ms latency on
      admin functions (which is acceptable).

  why_update_not_query:
    question: "Why are accounting functions 'update' calls now?"
    answer: |
      Because they query the ledger (another canister), which
      requires an update call. Query calls can't make inter-canister
      calls. The trade-off is worth it for fresh, accurate data.

  what_if_ledger_fails:
    question: "What happens if ledger query fails?"
    answer: |
      Functions return Result<T, String> errors. The refresh
      function returns 0 and logs the error for monitoring.

  can_house_go_negative:
    question: "Can house balance be negative?"
    answer: |
      Mathematically no, because house = canister - deposits.
      If this happens, it means either an exploit or a bug.
      The audit function would catch this.

  what_is_e8s:
    question: "What is e8s?"
    answer: |
      ICP uses 8 decimal places, like Bitcoin satoshis.
      1 ICP = 100,000,000 e8s (10^8)
      e8s = "eight zeros" = smallest unit
